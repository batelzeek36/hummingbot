"""
Hyperliquid Monster Bot v2.11 - GOD MODE Phase 4

This is the main orchestrator that coordinates the modular strategy components.
All strategy logic has been extracted into separate modules in the hyperliquid_monster/ package.

v2.11 CHANGES (GOD MODE PHASE 4 - ML SIGNAL CONFIRMATION):
- XGBoost Signal Confirmation: ML model as final quality gate for entries
- Feature Engineering: 24 normalized features from ALL indicators
- Online Learning: Model improves from each trade outcome (win/loss/stop/TP)
- Trade Outcome Tracking: Records entry features + exit results for continuous learning
- Funding Rate Prediction: ML model predicts funding rate direction
- Automatic model persistence: Saves/loads trained model between sessions
- Status display shows ML training status, win rate, and accuracy

v2.10 CHANGES (GOD MODE PHASE 3 - MULTI-TIMEFRAME CONFLUENCE + LIQUIDATION MAGNETS):
- Multi-Timeframe Confluence: 1m, 5m, 15m, 1h signal aggregation
- Weighted scoring: 1h (40%) > 15m (30%) > 5m (20%) > 1m (10%)
- Only enter when 3+ timeframes agree on direction
- Liquidation Magnet Detection: Price is "magnetically attracted" to liquidation clusters
- Blocks entries against strong liquidation magnetic direction
- CVD Divergence integration - detects trapped leverage traders
- Enhanced status display with MTF and Liquidation data

v2.9 CHANGES (GOD MODE PHASE 2 - COINGLASS INTEGRATION):
- CVD (Cumulative Volume Delta) from aggregated exchange data
- Spot vs Perp CVD Divergence - THE killer reversal signal
- Liquidation Heatmap - Know where liquidation clusters sit
- Long/Short Ratios - Contrarian crowding signals
- Full Coinglass API integration with caching and rate limiting

v2.8 CHANGES (GOD MODE PHASE 1):
- OI Spike Detection: Instant detection of violent OI changes (>5-10% in 30s)
- Premium Spike Detection: Sudden premium changes indicating rapid sentiment shift
- Market Regime Detection: Cross-market crowding analysis for squeeze prediction
- Order Book Velocity: Rate of change in order book imbalance for whale detection
- Enhanced entry blocking with should_block_entry_godmode()
- Iceberg order detection in order book

v2.7 CHANGES (HOLY GRAIL):
- Combined ALL leading indicators into single directional signal
- OI Momentum (35% weight) - New money entering/exiting
- Premium/Discount (25% weight) - Real-time directional pressure
- Funding Velocity (25% weight) - Momentum shifts and trend reversals
- Volume Surge (15% weight) - Breakout confirmation
- Blocks entries against combined signal direction
- Early exit when combined signal flips strongly

v2.6 CHANGES:
- Added Open Interest (OI) LEADING INDICATOR from Hyperliquid API
- OI confirms trend conviction (rising OI = new money entering)
- OI detects exhaustion (falling OI = profit taking / stops)
- OI blocks entries during squeeze/capitulation setups

LEVERAGE TIERS (based on volatility analysis 2026-01-11):
- SAFE (max daily <10%):     BTC -> 8x leverage
- MEDIUM (max daily <15%):   ETH, SOL, TAO -> 5x leverage
- HIGH (max daily <25%):     DOGE, HYPE, PURR, AVNT -> 3x leverage
- EXTREME (max daily 25%+):  kPEPE, kBONK, WIF, VVV, HYPER, IP -> 2x leverage

Target: 12-16% monthly returns on ~$80 capital

Capital Allocation ($78):
- Funding Harvesting: 45% ($35) - Smart leverage by coin (scans 13 pairs)
- Grid Trading: 35% ($27) - 5x on SOL (best liquidity)
- Directional: 20% ($16) - 8x on BTC (safest)

WHALE PROTECTION v2.5:
- Circuit Breaker: Detects rapid price spikes, pauses/flattens positions
- Grid Protection: Monitors fill rates, prevents one-sided accumulation
- Trailing Stop: Dynamic stop loss that locks in profits
- Dynamic Risk: Volatility-scaled stop losses, emergency market orders
- Early Warning: Order book imbalance and funding spike detection

Author: Dollar-A-Day Project
Date: 2026-01-12
Version: 2.9 (GOD MODE Phase 2) - COINGLASS CVD & LIQUIDATION DATA
"""

import sys
import os

# Add scripts directory to path for local module imports
_scripts_dir = os.path.dirname(os.path.abspath(__file__))
if _scripts_dir not in sys.path:
    sys.path.insert(0, _scripts_dir)

from datetime import datetime
from decimal import Decimal
from typing import Dict, Optional

from hummingbot.connector.connector_base import ConnectorBase
from hummingbot.core.data_type.common import OrderType, PositionAction, PositionMode, PriceType, TradeType
from hummingbot.core.event.events import OrderFilledEvent, FundingPaymentCompletedEvent
from hummingbot.strategy.script_strategy_base import ScriptStrategyBase

# Import from modular package
from hyperliquid_monster import (
    HyperliquidMonsterV2Config,
    StrategyMetrics,
    StrategyMode,
    PerformanceTracker,
    get_safe_leverage,
    PauseManager,
    StatusFormatter,
    log_startup_banner,
)
from hyperliquid_monster.strategies import (
    FundingHunterStrategy,
    GridStrategy,
    MomentumStrategy,
)
from hyperliquid_monster.whale_protection import WhaleProtectionOrchestrator


class HyperliquidMonsterBotV2(ScriptStrategyBase):
    """
    Modular multi-strategy Hyperliquid perpetual trading bot V2.

    This class serves as the orchestrator, delegating strategy logic to
    modular components in the hyperliquid_monster package.
    """

    # All validated Hyperliquid pairs
    markets = {"hyperliquid_perpetual": {
        "BTC-USD", "ETH-USD", "SOL-USD", "DOGE-USD", "TAO-USD",
        "HYPE-USD", "AVNT-USD",
        "kPEPE-USD", "kBONK-USD", "WIF-USD", "VVV-USD", "HYPER-USD", "IP-USD"
    }}

    @classmethod
    def init_markets(cls, config: HyperliquidMonsterV2Config):
        """Initialize markets based on config."""
        pairs = set()
        for pair in config.funding_scan_pairs.split(","):
            pairs.add(pair.strip())
        pairs.add(config.grid_pair)
        pairs.add(config.momentum_pair)
        cls.markets = {config.exchange: pairs}

    def __init__(self, connectors: Dict[str, ConnectorBase], config: HyperliquidMonsterV2Config = None):
        super().__init__(connectors)
        self.config = config if config is not None else HyperliquidMonsterV2Config()

        # Strategy metrics
        self.metrics = {
            "funding": StrategyMetrics(name="Funding Hunting"),
            "grid": StrategyMetrics(name="Grid Trading"),
            "momentum": StrategyMetrics(name="Momentum Trading"),
        }

        # Performance tracker
        self.performance_tracker = PerformanceTracker(logger=self.logger())
        self.performance_tracker.load_data()

        # Global state
        self.start_time = datetime.now()
        self.global_pnl = Decimal("0")
        self.total_funding_collected = Decimal("0")
        self.peak_equity = self.config.total_capital
        self.global_killed = False
        self._is_stopping = False
        self._first_run = True

        # Timing
        self.last_tick = 0
        self.tick_interval = 10
        self.last_risk_tick = 0

        # Initialize strategies (will be done after connector is ready)
        self._funding_strategy: Optional[FundingHunterStrategy] = None
        self._grid_strategy: Optional[GridStrategy] = None
        self._momentum_strategy: Optional[MomentumStrategy] = None

        # Pause Manager
        self._pause_manager = PauseManager(
            cancel_orders_fn=self._cancel_all_orders,
            close_positions_fn=self._close_all_positions,
            get_timestamp_fn=lambda: self.current_timestamp,
            logger=self.logger,
        )

        # Whale Protection Orchestrator
        self._whale_orchestrator: Optional[WhaleProtectionOrchestrator] = None

        # Status Formatter
        self._status_formatter = StatusFormatter(self.config, self.performance_tracker)

        self.logger().info("Hyperliquid Monster Bot V2.9 (GOD MODE Phase 2 - Coinglass) initialized!")

    def _init_strategies(self):
        """Initialize strategy instances."""
        connector = self.connectors[self.config.exchange]

        self._funding_strategy = FundingHunterStrategy(
            config=self.config,
            connector=connector,
            metrics=self.metrics["funding"],
            place_order_fn=self._place_perpetual_order,
            logger=self.logger(),
        )

        self._grid_strategy = GridStrategy(
            config=self.config,
            connector=connector,
            metrics=self.metrics["grid"],
            place_order_fn=self._place_perpetual_order,
            cancel_order_fn=lambda pair, order_id: self.cancel(self.config.exchange, pair, order_id),
            get_active_orders_fn=lambda: self.get_active_orders(connector_name=self.config.exchange),
            logger=self.logger(),
        )

        self._momentum_strategy = MomentumStrategy(
            config=self.config,
            connector=connector,
            metrics=self.metrics["momentum"],
            place_order_fn=self._place_perpetual_order,
            logger=self.logger(),
        )

        # Initialize whale protection
        self._init_whale_protection()

    def _init_whale_protection(self):
        """Initialize whale protection orchestrator."""
        self._whale_orchestrator = WhaleProtectionOrchestrator(
            config=self.config,
            pause_manager=self._pause_manager,
            logger=self.logger,
        )
        self._whale_orchestrator.set_emergency_close_fn(self._emergency_close_position)
        self._whale_orchestrator.initialize()

    def _emergency_close_position(self, pair: str):
        """Emergency close a position using market order."""
        connector = self.connectors[self.config.exchange]
        try:
            price = connector.get_price_by_type(pair, PriceType.MidPrice)
            if price:
                self.logger().warning(f"EMERGENCY: Attempting market close for {pair}")
        except Exception as e:
            self.logger().error(f"Emergency close failed for {pair}: {e}")

    # =========================================================================
    # STARTUP AND MAIN LOOP
    # =========================================================================

    def on_start(self):
        """Called when strategy starts."""
        log_startup_banner(self.config, self.logger)
        
        self._configure_exchange()
        self._init_strategies()
        self._is_stopping = False

        if self.config.funding_enabled:
            self.metrics["funding"].status = StrategyMode.ACTIVE
        if self.config.grid_enabled:
            self.metrics["grid"].status = StrategyMode.ACTIVE
        if self.config.momentum_enabled:
            self.metrics["momentum"].status = StrategyMode.WARMING_UP

    def _configure_exchange(self):
        """Configure exchange settings."""
        connector = self.connectors[self.config.exchange]

        try:
            connector.set_position_mode(PositionMode.ONEWAY)

            all_pairs = set()
            for pair in self.config.funding_scan_pairs.split(","):
                all_pairs.add(pair.strip())
            all_pairs.add(self.config.grid_pair)
            all_pairs.add(self.config.momentum_pair)

            for pair in all_pairs:
                safe_lev = get_safe_leverage(pair, self.config.max_leverage)
                connector.set_leverage(pair, safe_lev)

            self.logger().info(f"Exchange configured: {len(all_pairs)} pairs, smart leverage per coin")

        except Exception as e:
            self.logger().warning(f"Error configuring exchange: {e}")

    def on_tick(self):
        """Main loop."""
        if self.global_killed or self._is_stopping:
            return

        # First run activation
        if self._first_run:
            self._first_run = False
            if not self._funding_strategy:
                self._init_strategies()

            if self.config.funding_enabled:
                self.metrics["funding"].status = StrategyMode.ACTIVE
            if self.config.grid_enabled:
                self.metrics["grid"].status = StrategyMode.ACTIVE

            self.logger().info("Strategies activated on first tick")

        # === FAST RISK CHECK (every risk_check_interval seconds) ===
        risk_interval = getattr(self.config, 'risk_check_interval', 3)
        if self.last_risk_tick <= self.current_timestamp - risk_interval:
            self.last_risk_tick = self.current_timestamp
            self._run_whale_protection_checks()
            self._whale_orchestrator.check_auto_resume()

        # Check if whale protection has paused us
        if self._pause_manager.is_paused:
            return  # All trading paused - wait for conditions to normalize

        if self.last_tick > self.current_timestamp - self.tick_interval:
            return
        self.last_tick = self.current_timestamp

        # Risk check (legacy drawdown check)
        self._check_risk_limits()
        if self.global_killed:
            return

        # Run strategies
        if self.config.funding_enabled and self._funding_strategy:
            self._funding_strategy.run(self.current_timestamp)

        if self.config.grid_enabled and self._grid_strategy:
            if self._whale_orchestrator and self._whale_orchestrator.is_grid_paused():
                pass  # Grid is paused by protection
            else:
                self._grid_strategy.run()

        if self.config.momentum_enabled and self._momentum_strategy:
            self._momentum_strategy.run(self._update_global_pnl)
            self._update_trailing_stop()

        # Periodic performance save
        self.performance_tracker.check_save_interval(self.start_time, self.global_pnl)

    def _run_whale_protection_checks(self):
        """Run all whale protection checks."""
        if not self._whale_orchestrator:
            return

        connector = self.connectors[self.config.exchange]

        # Sync positions with circuit breaker
        self._whale_orchestrator.sync_positions_to_circuit_breaker(
            momentum_strategy=self._momentum_strategy,
            funding_strategy=self._funding_strategy,
            grid_strategy=self._grid_strategy,
        )

        # Get all monitored pairs
        all_pairs = set()
        for pair in self.config.funding_scan_pairs.split(","):
            all_pairs.add(pair.strip())
        all_pairs.add(self.config.grid_pair)
        all_pairs.add(self.config.momentum_pair)

        # Run protection checks
        self._whale_orchestrator.run_checks(connector, all_pairs, self.current_timestamp)

    def _update_trailing_stop(self):
        """Update trailing stop for momentum position."""
        if not self._whale_orchestrator or not self._momentum_strategy:
            return

        connector = self.connectors[self.config.exchange]
        self._whale_orchestrator.update_trailing_stop(
            momentum_strategy=self._momentum_strategy,
            connector=connector,
            momentum_pair=self.config.momentum_pair,
            stop_loss_pct=self.config.momentum_stop_loss,
            close_position_fn=lambda: self._momentum_strategy.close_position_for_shutdown(self._update_global_pnl),
        )

    def on_stop(self):
        """Called when strategy stops."""
        self.logger().info("Monster Bot V2 stopping...")
        self._is_stopping = True

        self._cancel_all_orders()
        self._close_all_positions()

        self.performance_tracker.save_data(self.start_time, self.global_pnl)
        self.logger().info("Shutdown complete.")

    # =========================================================================
    # ORDER PLACEMENT
    # =========================================================================

    def _place_perpetual_order(
        self,
        pair: str,
        side: TradeType,
        amount: Decimal,
        price: Decimal,
        leverage: int,
        position_action: PositionAction,
        strategy: str
    ) -> Optional[str]:
        """Place a perpetual order."""
        try:
            if side == TradeType.BUY:
                return self.buy(
                    connector_name=self.config.exchange,
                    trading_pair=pair,
                    amount=amount,
                    order_type=OrderType.LIMIT,
                    price=price,
                    position_action=position_action
                )
            else:
                return self.sell(
                    connector_name=self.config.exchange,
                    trading_pair=pair,
                    amount=amount,
                    order_type=OrderType.LIMIT,
                    price=price,
                    position_action=position_action
                )
        except Exception as e:
            self.logger().error(f"Order placement error: {e}")
            return None

    # =========================================================================
    # EVENT HANDLERS
    # =========================================================================

    def did_fill_order(self, event: OrderFilledEvent):
        """Handle order fills."""
        is_grid_order = False
        if self._grid_strategy and self._grid_strategy.handle_fill(event):
            is_grid_order = True
            # Track grid fill for protection
            if self._whale_orchestrator and event.trading_pair == self.config.grid_pair:
                side = "buy" if event.trade_type == TradeType.BUY else "sell"
                self._whale_orchestrator.record_grid_fill(
                    pair=event.trading_pair,
                    side=side,
                    price=float(event.price),
                    amount=float(event.amount),
                    order_id=event.order_id,
                    timestamp=self.current_timestamp
                )
        else:
            for strategy in ["funding", "momentum"]:
                self.metrics[strategy].total_trades += 1

        side = "BUY" if event.trade_type == TradeType.BUY else "SELL"
        self.logger().info(
            f"FILL: {side} {event.amount:.6f} {event.trading_pair} @ {event.price:.4f}"
        )

    def did_complete_funding_payment(self, event: FundingPaymentCompletedEvent):
        """Handle funding payment events."""
        self.total_funding_collected += event.amount
        self.metrics["funding"].funding_pnl += event.amount
        self.global_pnl += event.amount

        # Track per-coin performance
        coin_perf = self.performance_tracker.get_coin_performance(event.trading_pair)
        apr = 0.0
        if self._funding_strategy and event.trading_pair in self._funding_strategy.positions:
            apr = self._funding_strategy.positions[event.trading_pair].apr
        coin_perf.add_payment(float(event.amount), apr)

        self.logger().info(
            f"FUNDING RECEIVED: {event.trading_pair} ${event.amount:.4f} "
            f"(Session Total: ${self.total_funding_collected:.4f})"
        )

        self.performance_tracker.save_data(self.start_time, self.global_pnl)

    # =========================================================================
    # RISK MANAGEMENT
    # =========================================================================

    def _check_risk_limits(self):
        """Check global risk limits."""
        current_equity = self.config.total_capital + self.global_pnl

        if current_equity > self.peak_equity:
            self.peak_equity = current_equity

        if self.peak_equity > 0:
            drawdown = (self.peak_equity - current_equity) / self.peak_equity * 100

            if drawdown >= float(self.config.max_drawdown_pct):
                self.logger().error(
                    f"MAX DRAWDOWN REACHED: {drawdown:.2f}% - EMERGENCY SHUTDOWN"
                )
                self._kill_all()

    def _kill_all(self):
        """Emergency shutdown."""
        self.global_killed = True
        self._is_stopping = True
        self._cancel_all_orders()
        self._close_all_positions()

        for strategy in self.metrics.values():
            strategy.status = StrategyMode.KILLED

    def _update_global_pnl(self, pnl: Decimal):
        """Update global P&L (callback for strategies)."""
        self.global_pnl += pnl

    def _close_all_positions(self):
        """Close all open positions."""
        if self._funding_strategy:
            self._funding_strategy.close_all_positions(self.current_timestamp)

        if self._momentum_strategy:
            self._momentum_strategy.close_position_for_shutdown(self._update_global_pnl)

    def _cancel_all_orders(self):
        """Cancel all orders."""
        if self._grid_strategy:
            self._grid_strategy.cancel_all_orders()

        for order in self.get_active_orders(connector_name=self.config.exchange):
            self.cancel(self.config.exchange, order.trading_pair, order.client_order_id)

    # =========================================================================
    # STATUS DISPLAY
    # =========================================================================

    def format_status(self) -> str:
        """Display bot status."""
        return self._status_formatter.format_status(
            start_time=self.start_time,
            global_pnl=self.global_pnl,
            total_funding_collected=self.total_funding_collected,
            peak_equity=self.peak_equity,
            global_killed=self.global_killed,
            metrics=self.metrics,
            funding_strategy=self._funding_strategy,
            momentum_strategy=self._momentum_strategy,
            grid_strategy=self._grid_strategy,
            whale_orchestrator=self._whale_orchestrator,
            pause_manager=self._pause_manager,
            current_timestamp=self.current_timestamp,
        )
